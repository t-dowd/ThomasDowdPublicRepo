TITLE: 
Thomas Dowd
MineSweeper++
CSCI Section C


PROBLEM DESCRIPTION: I plan on making the popular game Minesweeper in C++ I will use self-made 
functions to create a procedurally generated game map and a durable algorithm to decide if the position 
selected is a valid location. I also want to utilize SFML and its vast library to implement mouse 
functionality to interact with the game. 


PROGRAM DOCUMENTATION:

This program will need to be run with SFML. 
As a note to the player, as the SFML window is opening do not click 
to open the tab, the software will register this as a click and place an errant selection. 
Also, the screen size is a fixed size, do not reformat the screen, the static grid made to register 
clicks does not scale. 

I made major changes to my original problem statement, the most 
obvious of which is the fact I am no longer using ASCII code implemented in the terminal, I decided 
to give myself a challenge and use SFML. This was necessary because I felt that Minesweeper 
without SFML is too easy, it also just looked unappetizing, ugly, and hard to use for a new player. 
I also switched from a variable difficulty and variable board size due to my rudimentary knowledge of SFML.

If I had more time I would make a function that checks if the 
game is won or lost, I ran out of time while writing one and hit one too many roadblocks. I would also 
have liked to implement a variable-sized board and a more resilient click register function, it is quite 
finicky at the moment (as you will soon find out).


LIST DATA STRUCTURE:

MineSweeper++ uses two types of data structures quite frequently, the most obvious, is the dynamic 
array of “GameNodes”. This was beneficial because I was constantly messing around with the bounds, number 
of tiles, and overall size, the array of Game Nodes keeping up was very helpful. The less 
obvious data structure used was the frequent use of SF’s sf::vector<type>. I learned about this 
recently and I used it frequently for x and y coordinates. It is exponentially better and easier to 
read than the “Pair” functionality. 


TESTS:
1. Player inputs more mine than intended in the source code?
        The program will not break and will simply add that many more mines. 
2. Player moves the mouse off the screen and clicks.
        The program will not break, it will simply click on the last known location of the mouse.
3. Player wins/loses the game?
        The game will close automatically if all Mines have Flags on them.
4. Player does not close out the tab, after completing the game?
        The game will go to sleep when the computer goes to sleep.
5. Player resizes window?
        The game closes and declares that the player may not resize the window.

REFLECTIONS:
        I learned a lot over the course of the project I made something I am genuinely proud of. If I were to do this differently I would have started the project with private variables rather than retroactively making some variables private.